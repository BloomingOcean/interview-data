## 一、JVM的主要组成？及其作用（引出 类加载机制、运行时数据区）

- 类加载器（ClassLoader）

- 运行时数据区（Runtime Data Area）

- 执行引擎（Execution Engine）

- 本地库接口（Native Interface）

组件作用：首先类加载器（涉及类加载机制）会把类加载为字节码，然后通过运行时数据区把字节码加载到内存中（引出运行时数据区结构），但是即便把类加载为了字节码，电脑还是看不懂，所以这个时候就需要执行引擎把字节码翻译为机器语言，再交给cpu去实现。而这个过程有可能会调用外部接口，也就是本地库接口

## 二、说一说类加载机制（引出类加载器、整个运行时数据区都可能被引出） 

类的生命周期主要分为7个过程，分为加载、（验证、准备、解析）连接、初始化、使用、卸载。而类加载的过程就是前面的加载和连接部分。

首先是加载，加载器通过双亲委派机制进行加载，把字节码文件加载到方法区的运行时数据结构，然后在堆中生成一个代表这个类的Class文件，作为刚刚加载到方法区的运行时数据的访问入口。

然后是连接部分，连接部分首先是验证，验证这个过程目的就是为了确保类的正确性。准备阶段主要是为类变量分配内存（方法区）并设置初始值。解析是把常量池中的符号引用转化为直接引用的过程。

而最后就是初始化。初始化的任务是对类静态变量赋予初始值。

类初始化步骤：

1. 假如这个类还没有被加载和连接，则程序先加载并连接该类
2. 假如该类的直接父类还没有被初始化，则先初始化直接父类
3. 假如类中有初始化语句，则系统执行这些初始化语句

什么时候初始化？

- new 创建类的实例
- 访问某个类或接口的静态变量，或对静态变量赋值
- 调用类的静态方法
- 反射（如Class.forName("com.liyang.Test")）
- 初始化某个类的子类，则父类也会被初始化
- java虚拟机启动时被标明为启动类的类（javaTest、Application），直接使用java.exe来运行这个类

## 三、类加载器

类加载器定义：类加载器是把java文件加载为字节码文件的加载器。

而类加载器的主要有两种，一种是系统提供的类加载器，另一种就是开发者自定义的类加载器。而系统提供的类加载器分为3种，分别是启动类加载器、扩展类加载器、应用程序类加载器。那我们有这么多加载器，为什么加载器要分这么多类型去加载？这就要涉及一个加载安全机制了，那就是双亲委派机制。双亲委派的工作流程是：如果一个类收到了加载一个类的请求，它首先不会自己加载，而是把这个请求转发给它的父类，然后一直向上转发到启动类加载器中。只有当父类加载器不能加载此类的时候才会把请求向下传递。整个机制保证的安全性是：如果有别有用意的人修改了java核心类库的功能，那么那个有安全隐患的类就不会被根加载器加载，因为根加载器搜索不到这个类。所以通过双亲委派的这种机制，避免了这种安全隐患。

## 四、说一说运行时数据区（没有很详细）

运行时数据区分为5个部分：程序计数器、本地方法栈、java堆、java虚拟机栈、方法区

程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解析器的工作就是通过改变这个计数器的值来选取下一条需要执行的字节码指令

java虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作数栈、动态链接、方法出口等信息

本地方法栈（Native Method Stacks）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务Java方法的，而本地方法栈是为虚拟机调用的Native方法服务的

Java堆（Java Heap）：拥有java虚拟机中最大的内存，被所有线程共享，几乎所有的对象实例都在这里分配内存

方法区（Method Area）（注意1.7和1.8的区别）：用于已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据

方法区扩展：

1. 1.7版本字符串常量区在永久代，1.8就放在了堆中了（1.8也没有永久代了）
2. 元数据区（1.8）和永久代（1.7）都是对JVM规范中的方法区的实现。方法区存放虚拟机加载的类信息、静态变量、常量等数据

## 五、（扩展）Java中的内存分配策略

- 静态存储分配：是指**在编译时，就能确定每个数据在运行时的存储空间**，因而在编译时就可以给他们分配固定的内存空间。这种分配策略要求程序代码中不允许有可变数据结构的存在，也不允许有嵌套或者递归的结构出现，因为它们都会导致编译程序无法计算准确的存储空间需求。
- 栈式存储分配：也可称为动态存储分配，是由一个类似于堆栈的运行栈来实现的。和静态存储分配相反，在栈式存储方案中，程序对数据区的需求在编译时是完全未知的，只有到运行的时候才能够知道，也就是规定**在运行中进入一个程序模块时，必须知道该程序模块所需的数据区大小**才能够为其分配内存。栈式存储分配按照先进后出的原则进行分配。
- 堆式存储分配：**静态存储分配要求在编译时能知道所有变量的存储要求，栈式存储分配要求在过程的入口处必须知道所有的存储要求**，而堆式存储分配则专门负责在编译时或运行时模块入口处都无法确定存储要求的数据结构的内存分配，比如可变长度串和对象实例。堆由大片的可利用块或空闲块组成,堆中的内存可以按照任意顺序分配和释放。

## 六、Java堆、java虚拟机栈的区别

功能：堆主要用来存放对象的，栈主要是用来执行程序的

1. 栈。可以看成是方法的运行模型，所有方法的调用都是通过栈帧来进行的，JVM会为每个线程都分配一个栈区，JVM对栈只进行两种操作：以帧为单位的压栈和出栈操作。当线程进入一个Java方法函数的时候，就会在当前线程的栈里压入一个栈帧，用于保存当前线程的状态（参数、局部变量、中间计算过程和其他数据），当退出函数方法时，修改栈指针就可以把栈中的内容销毁。
2. 堆。唯一的目的就是用于存放对象实例，每个Java应用都唯一对应一个JVM实例，每个JVM实例都唯一对应一个堆，并由堆内存被应用所有的线程共享。

性能：栈快，但缺乏灵活；堆灵活，但缺乏效率

1. 栈。性能比堆要快。但是，在分配内存的时候，存放在栈中的数据大小与生存周期必须在编译时是确定的，缺乏灵活性。
2. 堆。堆可以动态分配内存大小，编译器不必知道要从堆里分配多少存储空间，生存周期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据，因此可以得到更大的灵活性。但是，由于要在运行时动态分配内存和销毁对象时都需要占用时间，所以效率低。

共享：堆是线程共享的，栈是线程私有的

## 七、怎么判断对象是否可以被回收？

1. 引用计数法：为每一个对象创建一个引用计数，每有一个对象引用它时，这个计数器就+1，引用被释放就-1，当计数器为0时就可以被回收，但是这个方法不能判断循环引用
2. 根可达算法：从GC Root开始向下搜索，一个对象到GC Root中没有任何一个对象引用它，那么此对象是可回收的。

## 八、Java中有哪些引用类型

强引用：GC回收的时候都不回收

软引用：发生内存溢出之前会回收的对象

弱引用：每一次GC都会回收

虚引用（幽灵引用、幻影引用）：无法通过虚引用获得一个对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知

## 九、JVM有哪些垃圾回收算法

- 标记-清除算法：标记无用对象，然后进行清理。缺点：效率不高，无法整理分散内存
- 标记-整理算法：标记无用对象，让所有没被标记的对象向一端移动，然后直接清除掉所有标记对象。缺点：执行流程相对较多，效率不高
- 复制算法：按照容量把内存一分为二，把一个内存中活着的对象复制到另一块内存上，然后把之前的内存清除掉。缺点：空间利用率低，只有原来的一半
- 分代算法：根据对象存活周期把内存分为几块，一般是新生代和老年代。新生代基本都是用复制算法，老年代使用标记整理算法

## 十、JVM有哪些垃圾回收器（需要再深入了解）

1. Serial [ˈsɪriəl]：最早的单线程串行垃圾回收器，采用复制算法

2. Serial Old：老生代版本，也是单线程的，使用标记整理算法，可作为CMS垃圾回收器的备选方案

3. ParNew：是Serial/Serial Old的多线程版本

4. Parallel  [ˈpærəˌlɛl]：和ParNew都是多线程，但Parallel是吞吐量有限的收集器，可以牺牲等待时间换取系统的吞吐量

5. Parallel Old：老生代版本。Parallel使用的是“复制算法”的内存回收算法。Parallel Old使用的是“标记整理算法”的内存回收算法

6. CMS：一种以获得最短停顿为目标的收集器，适用于B/S系统

7. G1：一种兼顾吞吐量和停顿时间的GC实现，是JDK9之后的默认GC实现

   注：jdk1.8默认使用的是Parallel回收器管理新生代，使用Parallel Old管理老年代

## 十一、详细介绍一下CMS垃圾回收器

注：在启动 JVM 的参数加上“­XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。

CMS（Concuurent Mark-Sweep），是牺牲吞吐量以获得最短回收暂停时间的垃圾回收器。适合B/S服务器这种需要高响应速度的服务。

CMS是使用的标记-清除算法实现的，所以会产生大量的碎片，当碎片过多的时候，系统会出现Concurrent Mode Failure。临时CMS会使用Serial Old回收器（使用标记整理算法）进行垃圾清除，这个时候性能将会降低。

## 十二、新生代垃圾回收器和老年代垃圾回收器有哪些？有什么区别？

新生代回收器：Serial、ParNew、Parallel Scavenge

老年代回收器：Serial Old、Parallel Old、CMS

整堆回收器：G1

区别：新生代的垃圾回收器一般采用的是复制算法，因为新生代的GC频率高；老年代回收器一般采用的是标记-整理算法进行垃圾回收，因为老年代需要的是内存使用率，而GC的频率比较低。

## 十三、分代垃圾回收器（就是指的垃圾回收器，只不过需要阐明代与代的流程）是如何工作的

分代回收器有两个分区：新生代和老生代，新生代的默认空间占比是1/3，老生代是2/3。

新生代使用的是“复制算法”，新生代有3个区：Eden、To Survivor、From Survivor，他们默认比例是8：1：1。

执行流程：

1. 把Eden和From Survivor 存活的对象放入To Survivor区；
2. 清空Eden和From Survivor分区
3. From Survivor 和 To Survivor 分区交换，From Survivor 区变为To Survivor区
4. 每次在From Survivor 到 To Survivor移动都存活的对象，年领就+1，当年领大于15（默认是15）的时候，升级为老生代。大对象也会直接进入老生代
5. 老生代空间占满了就会触发全局垃圾回收（老生代垃圾回收器），一般使用标记整理算法。

## 十四、常用JVM调优工具

JDK自带的监控工具，都位于JDK的bin目录下，其中最常用的是jconsole和jvisualvm这两款

- jconsole：用于对JVM中内存、线程、类进行监控
- jvisualvm：JDK自带的全能分析工具，可以分析：内存快照、线程快照、线程死锁、监控内存的变化、gc变化等

## 十五、JVM常用的调优参数

-Xms2g：初始化堆的大小为2g

-Xmx2g：堆最大内存为2g

-XX:NewRatio=4：设置年轻代和老年代的比例为4

-XX:SurvivorRatio=8：设置Eden和Survivor的比例为8：2

-XX:+UseParNewGC：使用指定的ParNew + Serial Old 垃圾回收器组合

-XX:+UseParallelOldGC（有问题）：指定使用 ParNew + ParNew Old 垃圾回收器组合

‑XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合

‑XX:+PrintGC：开启打印 gc 信息

‑XX:+PrintGCDetails：打印 gc 详细信息