## 一、面向对象和面向过程的区别（可以引出面向对象的特征的问题）

面向过程解决问题是直接把问题的每一个步骤分析出来，然后用函数把每一个步骤一步一步的实现；面向对象是将解决问题相关的事物，转化为对象。那么面向对象解决问题也就不是为了完成一个流程了，而是描述某个对象在解决问题的时候做什么事情，也就是描述对象的行为。

|      |            面向对象            |               面向过程               |
| :--: | :----------------------------: | :----------------------------------: |
| 特征 |    封装、继承、多态、(抽象)    |              代码流程化              |
| 优点 | 易维护、易复用、易扩展、低耦合 | 性能高、适合资源紧张、实时性强的场合 |
| 缺点 |        性能比面向过程低        |     不易维护、复用、扩展、高耦合     |

## 二、封装、继承、多态、（抽象）（引出  权限修饰符、重写载、）	

封装：隐藏对象的属性和方法实现细节，仅提供公共的对外访问方法（好处：隐藏了功能实现细节，提供公共访问接口、提高代码复用性（属性做成方法，继承便可以使用）、提高安全性）

继承：把已有的类作为基础来创建新类的一种技术，新类可以使用父类的功能，也可以重写父类的方法实现自己的方法（好处：实现了代码重用、可扩展性）

多态：不同对象对同一消息产生不同的响应，即在不同子类中，调用同一方法而使用不同的方法策略（好处：根据不同的子类，分别重写不同的功能，实现不同的业务）

多态的三个必要条件：继承、方法重写、父类引用指向子类

## 三、权限修饰符

|  修饰符   | 类内部 | 同一个包 | 子类 | 任何地方 |
| :-------: | :----: | :------: | :--: | :------: |
|  private  |  yes   |          |      |          |
| （缺省）  |  yes   |   yes    |      |          |
| protected |  yes   |   yes    | yes  |          |
|  public   |  yes   |   yes    | yes  |   yes    |

## 四、重写（Override）和重载（Overload）（引出 设计模式、OOP原则）

重写和重载都是实现多态的方式，区别在于重写是运行时的多态，重载是编译时的多态。重载发生在一个类中，多个同名的方法有着不同的参数、返回类型，根据不同参数运行不同的方法。重写是发生在父类和子类之间，根据面向对象7大原则中的"里氏替换原则”，子类继承的父类方法必须要有相同的参数类型以及更加宽泛的返回值类型，子类的方法要比父类要更好的访问，也就是权限修饰是更宽泛的范围，也不能比父类有更多的异常类型。

## 五、OOP（Object Oriented Programming）七大原则

### 1、开闭原则

原则：对扩展开放，对修改关闭

### 2、依赖倒置原则

原则：是开闭原则的衍生。核心思想是面对接口编程，不要面对具体实现编程。（例：方法的形参是一个抽象类或者接口，那么这个方法的参数就可以是这个抽象类或接口的所有的实现类）

### 3、里氏替换原则（重在 即便是子类替换了父类，对程序依旧没有影响）

原则：当有两个类是继承关系时，子类不能修改父类的非抽象方法和变量

**替换的含义**：当有父类出现的地方，这个父类可以替换成子类，并且对程序没有影响，这就遵循了里氏替换原则；当替换成子类时对程序有影响，说明了子类修改了父类的方法，就没有遵循里氏替换原则

#### Question：面向对象的多态是否违背了里氏替换原则？

里氏替换原则要避免重写父类的非抽象方法，而多态的实现是通过重写抽象方法实现的，所以并未违背。

### 4、合成复用原则

原则：要求在软件复用时，要尽量使用 组合和聚合 的关联方式来实现，其次才考虑使用继承关系来实现如果要使用继承关系，则必须严格遵循里氏替换原则

### 1&2&3&4的联系

- 开闭原则是一切的基础，依赖倒置原则是实现开闭原则的途径之一，也是衍生之一。

- 里氏替换原则和合成复用原则相辅相成，两者都是开闭原则的具体实现规范。

### 5、单一职责原则

### 6、接口隔离原则

原则：要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。也就是要为各个类建立他们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去使用。

#### Question：程序接口细粒度的过大和过小，有什么影响？

如果细粒度控制的太小，会导致接口数量增加。可能一个功能只需要两三个类，但是细粒度太低的话就可能会需要七八个甚至更多的接口。这样的话程序耦合度是降低了，但是维护不方便。如果粒度太大，耦合度就会高，程序不灵活。所以这个原则需要开发者有足够的实践经验。

### 5&6的异同

单一职责原则和接口隔离原则都是为了提高类的内聚性，降低它们之间的耦合度，体现了封装的思想，但是这两者是不同的。

- 单一职责原则注重的是职责；而接口隔离原则注重的是对接口的依赖的隔离；

- 单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体架构的构建。

### 7、迪米特法则（最小知道原则）

原则：只和自己的朋友直接对话，不和陌生人直接对话。一个类对外暴露的越少越好

例：当A类需要调用B类的三个方法才能实现的功能，B类可以对这3个方法进行一个封装，然后只暴露封装的这个方法给A，这样A就只需要调用B的这个封装的方法就好了。（最小知道）当B中的三个方法需要修改的时候，也只需要修改B中方法的实现，而不需要修改A中是怎样调用B的方法。A不需要管B是如何实现的方法，只需要调用B提供给A的方法就行了，这样就降低了程序之间的耦合性。

#### Question：迪米特法则中的“朋友”是指？

当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等。这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。

### 总结（比如像伯特兰·迈耶在1988年发行的《面向对象软件构造》提出了开闭原则）

OOP面向对象程序设计的这些原则设计之初的目的就是为了降低耦合度、提高代码复用率、提高程序灵活程度。无论使用什么原则，无论是否遵循这7条规则，只要程序设计得更加灵活完善，那么这也是契合实际项目的一个好的解决方案。（可以举一个故事，汉谟拉比法典，刑事、贸易、婚姻等制度都作了详细的规定。）

## 六、设计模式

单独写一个文档

## 七、String和StringBuffer和StringBuilder的区别（提到了数组操作、JVM、锁）

两个方面：运行速度、线程安全

运行速度：StringBuilder  >  StringBuffer  >  String (主要提及String和其它两种的差别就行)

StringBuilder和StringBuffer保存的是字符串变量（底层是char[ ]数组），而String保存的是字符串常量，String值的变化不仅仅是自身的变化，如果给String变量变了一个值，那么jvm会先创建一个字符串对象，这个创建的新对象的值才是被改变后的字符串的值，然后再把新对象的地址赋值给原来的String变量里。所以String更改是很麻烦的，且消耗资源，如果对字符串经常进行修改则适合使用另外两种。

线程安全：只有StringBuffer是线程安全的

StringBuffer的方法是加上了synchronized保证了多线程操作的安全性。但是StringBuilder是没有保证线程安全的。

String：适用于少量的字符串操作情况

StringBuilder：适用于单线程下在字符缓冲区进行大量操作（适合单线程操作，速度是最快的）

StringBuffer：适用于多线程下在字符缓冲区进行大量操作（适合多线程操作）

## 八、（小点）System.out.println（Object）toString ==

其实执行的是Object类的toString方法（Obj默认的toString方法就是会打印出对象的地址）

String类打印出来不是String常量的地址，是因为String类重写了Obj类的toString方法，使其打印的是字符串。

== 是比较的地址

## 九、== 和 equals的区别

== ：对于基本类型和引用类型，== 的作用效果是不同的

- 基本类型：比较的是值是否相同
- 注：基本类型有8种 byte、char、short、int、float、long、double、boolean
- 引用类型：比较的是地址是否相同

equals：Object默认的equals方法

```java
public boolean equals(Object obj) {
    // 所以如果不重写equals方法，equals方法实质上还是 == 
    return (this == obj);
}
```

String的equals方法

```java
public boolean equals(Object anObject) {
    // 如果String类对象和参数对象是一个对象
    if (this == anObject) {
        return true;
    }
    if (anObject instanceof String) {
        String anotherString = (String) anObject;
        // value指的是当前类的字符串
        int n = value.length;
        if (n == anotherString.value.length) {
            char v1[] = value;
            char v2[] = anotherString.value;
            int i = 0;
            // 把本类的字符串值与参数字符串一一比对
            while (n-- != 0) {
                if (v1[i] != v2[i])
                    return false;
			   i++;
            }
            // 两个字符串值相等
            return true;
        }
    }
    // 说明anObject不是个字符串
    return false;
}
```

从源码上来看，说明实际上String类的equals是经过了重写，把 == 判断重写为了字符串值判断。

## 十、两个对象的hashCode()相同，equals()是否也为true？（专门就为引出数据结构、红黑树）

## 十一、Math.round()方法：四舍五入，向右取整

## 十二、如何将字符串进行反转？String类常用的方法？





