# MySQL

## 一、数据库三范式

第一范式：要求每一列的原子性，也就是不可拆分

反例：

| userID | userName |              region              |
| :----: | :------: | :------------------------------: |
|   1    |   张xx   | 河南省、开封市、朝阳区新华路23号 |
|   2    |   李xx   | 河南省、开封市、朝阳区新华路24号 |
|   3    |   王xx   | 河南省、开封市、朝阳区新华路25号 |

第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖指不能存在仅依赖主关键字一部分的属性

反例：商品名称只依赖于商品编号，客户和联系方式只依赖于订单编号。所以需要分成两个表（或3个）

| 订单编号 | 商品编号 | 商品名称 | 客户 |   联系方式   |
| :------: | :------: | :------: | :--: | :----------: |
|   001    |    1     |  挖掘机  | 张三 | 020-14231235 |
|   002    |    2     |  冲击钻  | 张三 | 021-43514352 |
|   003    |    3     |   铲车   | 李四 | 046-12346576 |

第三范式：任何非主属性不能依赖别的非主属性

反例：在表中userLevel依赖于userID，userID依赖于studentNO和cardNO，形成了传递依赖。第三范式就是为了消除这种传递依赖而设立的。（需要把userID和userLevel另建一个表）

| studentNO | cardNO | userID | userLevel |
| :-------: | :----: | :----: | :-------: |
|   20001   |   1    |  001   |  操作员   |

## 二、一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 MySQL 数据库，又插入 了一条数据，此时 id 是几？

- 表类型如果是MyISAM，那id就是8

- 表类型是innoDB，那id就是6

  注：innoDB会把自增主键的最大id存储在内存中，所以重启之后会导致最大id丢失

## 三、ACID

- A（Atomicity 原子性）：一个事务的操作，或全部完成，或全部不完成。不会结束在中间某个环节。事务在执行过程中发生错误会被回滚到事务发生前的状态。即事务的不可分割、不可约简
- C（Consistancy 一致性）：在事务开始之前和完成之后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等
- I（Isolation 隔离性）：数据库允许多个事务同时对数据进行读写和修改功能，隔离可以预防因多个并发事件交叉执行而导致的数据不一致问题。事务隔离性可以分为（读未提交，读提交，可重复读、序列化（串行化））
- D（Durability [ˈdɚ] ['gɚ]持久性）：事务提交后，对数据库的修改是永久的，提交之后就算是系统崩溃也不会改变已提交数据

## 四、char和varchar的区别

char(n)：固定长度，比如char(10)的字段有一个"abc"的数据，那么这个这数据所占空间是10个字节，3个字节被“abc“占用，剩下7个字节是空。

varchar(n)：可变长度，存储的是数据所占字节+一个用来记录长度的字节

综合：char的效率高，但是空间浪费多，适合固定长度字段（MD5密码，身份证号，电话号码等）。varchar是可变长度，空间效率高，但是速度慢点，适合数据长度不固定的字段。

## 五、数据库的事务隔离（4种）(不是很理解最后几种是怎么隔离的)

数据库的事务隔离配置是在MySQL.ini配置文件的：transaction­isolation = REPEATABLE­READ配置的

- READ-UNCOMMITTED（读未提交）：最低隔离级别，在事务未提交前，别的事务也可以读取数据（会出现脏读、幻读、不可重复读）
- READ-COMMITTED（读提交）：一个事务提交之后，数据才能被别的事务读取（会产生幻读、不可重复读）
- REPEATABLE-READ（可重复读）：默认级别。保证多次读取同一个数据时，其值和事务在开始时候内容都是一致的，禁止读取到别的事务为提交的数据（会产生幻读）
- SERIALIZABLE（序列化）：是代价最高的隔离级别，并发情况下会很慢（不会产生脏读、幻读、不可重复读）

## 六、脏读、不可重复读、幻读

- 脏读：事务能够读取到别的事务中未提交的数据。比如：事务A插入了一条数据a，这时事务B把数据a读取了，但是事务A发生了错误，执行回滚，数据a被清除。但是数据a却被B读取了。

  |              会话1               |               会话2                |
  | :------------------------------: | :--------------------------------: |
  |              begin               |               begin                |
  |                                  | update table set age=10 where id=1 |
  | select age from table where id=1 |                                    |
  |              commit              |               commit               |

  

- 不可重复读（我觉得这个就应该叫叫“可重复读”）：指在一个事务中，多次读取一个数据，但是数据不一致

  |              会话1               |               会话2                |
  | :------------------------------: | :--------------------------------: |
  |              begin               |               begin                |
  | select age from table where id=1 |                                    |
  |                                  | update table set age=10 where id=1 |
  |                                  |               commit               |
  | select age from table where id=1 |                                    |
  |              commit              |                                    |

  

- 幻读：一次事务内查询返回的结果集不一样，比如一个事务第一次查询有n条数据，第二次查询就变成了n+1条数据，就好像产生了幻觉，所以叫幻读。产生的原因是：事务A第一次和第二次读取期间，有另外的事务对数据进行了增加删除修改操作，导致前后数据不一致。

  |              会话1               |                  会话2                  |
  | :------------------------------: | :-------------------------------------: |
  |              begin               |                  begin                  |
  | select age from table where id>2 |                                         |
  |                                  | insert into table(id, age) value(5, 10) |
  |                                  |                 commit                  |
  | select age from table where id>2 |                                         |
  |              commit              |                                         |

  注：不可重复读一般表示的是一行数据的更改，而幻读一般表示的是总数的变化。

## 七、MySQL常用的引擎（还需要更加深入了解一下）

- InnoDB
  1. 提供了对数据库的ACID事务的支持
  2. 不支持全文搜索
  3. 不会保存表的行数的，所以当进行select count(*) 操作的时候，需要扫描全表
  4. 提供了行级锁和外键的约束，锁的粒度很小，写操作是不会锁定全表，所以适合在并发比较高的情况下
- MyIASM：
  1. 不提供事务的处理
  2. 支持全局搜索
  3. 但是MyIASM保存了表的行数，于是进行select count(*)的时候，可以直接读取保存的值，而不需要扫描全表
  4. 不支持行级锁和外键约束，所以锁的粒度较大，执行插入和更新语句时，需要锁定整个表，所以效率较低

选择：如果表的读操作远远大于写操作，并且不需要事务的支持的时候，MyIASM引擎更适合。innoDB更加适合增加修改删除较多的场景。

## 八、说一下MySQL的行锁和表锁（引出 死锁）

MyISAM [my-z [ei]m] 只支持表锁，InnoDB支持表锁和行锁，默认为行锁

- 表锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低
- 行锁：开销大，加锁慢，会出现死锁。锁定粒度小，发生锁冲突的概率低，并发量最高

## 九、说一下乐观锁和悲观锁

- 乐观锁：很乐观的认为拿取数据期间不会有别人来修改，所以不会加锁。但是会在提交更新之前判断一下在此期间数据有没有被修改。

- 悲观锁：很悲观的认为只要自己拿了数据，就会有人来修改数据，所以自己拿了数据之后就会对这个数据进行加锁。

  乐观锁需要开发者自己实现，在表里加一个version字段，每次修改之后就+1，每次提交之前都会判断一下版本是否是拿数据之前的版本。

## 十、MySQL数据优化的方向

1. 为搜索字段创建索引
2. 避免使用select *
3. 垂直分割分表
4. 选择正确的存储引擎

## 十一、B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据

在B+树的索引中，叶子节点可能只存储了当前的key值（非聚簇索引），也可能存储了当前key值以及整行的数据（聚簇索引），这就是聚簇索引和非聚簇索引。在InnoDB中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引。如果没有唯一值，则隐式的生成一个键来建立聚簇索引。

当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表操作。

## 十二、什么是聚簇索引？如何使用聚簇索引和非聚簇索引？

- 聚簇索引：将数据与索引放在一起，查到了索引也就查到了其它数据
- 非聚簇索引：将数据通过索引分开存储，索引结构的叶子节点指向了数据的对应行

辅助索引：innodb中，在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值

## 十三、非聚簇索引一定会回表查询么？（引出 聚簇索引、覆盖索引）

不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中，那么久不需要再进行回表查询。

举例：select age from employee where age < 20（age是索引），在索引的叶子节点上已经包含了age信息，不需要再进行回表查询了

## 十四、联合索引是什么？为什么需要注意联合索引中的顺序？

MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要想要命中索引，则需要按照建立索引时的字段顺序挨个使用，否则无法命中。

举例：新建一个联合查询（name,age,school）一个索引

MySQL使用索引时需要索引有序，假设现在建立了"name，age，school"的联合索引，那么索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。所以一般情况下选择查询较为频繁的字段放在联合索取前面。

## 十五、如何实现前缀索引

语法：index（field（10）），使用字段前10歌个字符建立索引。默认是使用字段全部值作为索引

前提：前缀的标识度很高。比如MD5密码就适合建立前缀索引，因为MD5密码的前面很难有相同的

实操的难度：在于前缀截取的长度

判断合适长度的方法：利用select count(*) / count(distinct left(password , prefixLen));（查看前prefixLen长度的相同字符串的个数），通过从调整prefixLen的值（从1自增）查看不同前缀长度的一个平均匹配度，接近1时就可以了（表示一个密码的前prefixLen个字符几乎能确定唯一一条记录）

## 十六、最左前缀原则？最左匹配原则？

- 最左前缀原则：就是最左优先，在创建多列索引时，会根据业务需求，where语句查找最频繁的字段放在最索引左边
- 最左匹配原则：mysql会一直向右匹配，直到遇上范围查询（<，>，between，like）就停止匹配，比如a =1 and b =2 and c > 3 and d =4，如果建立（a,b,c,d）的联合索引，d是用不上索引的。但是如果创建（a,b,d,c）的联合索引就都可以用上索引。a,b,d的位置可以任意调换。





# Redis

## 一、Redis 和 memcache 有什么区别？（Redis支持哪些数据类型？5种）

存储方式不同：memcache把数据全部存储在内存之中，断电后会挂掉，数据不能超过内存大小。Redis有部分存储在硬盘上，这样保证了数据的持久性

数据支持类型：memcache只支持String的数据类型，而Redis支持string（字符串）、list（列表）、hash（字典）、set（集合）、 zset（有序集合）

value值大小不同：Redis的value可以存储1gb，而memcache只有1mb

## 二、Redis为什么是单线程的

cpu不是Redis的瓶颈，Redis的瓶颈更多的来自于机器内存或网络宽带。居然单线程更加容易实现，并且cpu又不会成为瓶颈，那就使用了单线程来实现。

Redis的性能，即便是普通笔记本的cpu，也可以处理每秒几十万条数据。

## 三、缓存穿透

缓存穿透：指查询一个一定不存在的数据，由于这个数据在缓存中是不存在的，所以需要从数据库中查询，查不到数据则不写入缓存，这将导致每次查询这个不存在的数据的时候都会经过缓存，然后还是要去数据库查询。

解决方案：最简单粗暴的方法就是判断如过查询到的数据为null，就对这个数据在缓存中对这个数据进行“空”缓存，但是这个缓存的存在时间很短，最长不超过5分钟。

## 四、Redis的客户端有哪些？都有哪些区别？

- Jedis：提供了比较全面的Redis命令的支持
- Redisson：实现了分布式和可扩展的java数据结构，与Jedis相比Redisson的功能相对简单，不支持排序、事务、管道、分区等Redis特性

## 五、如何保证缓存和数据库的一致性

解决方法：设置合理的缓存过期时间

新增、更改、删除数据库操作时同步更新Redis，可以使用事务机制来保证数据的一致性

## 六、Redis持久化的两种方式

- RDB（Redis Database）：指定的时间间隔能对你的数据进行快照存储
- AOF（Append Only File）：每一个收到的写命令都通过write函数追加到文件中

## 七、Redis如何实现分布式锁



## 八、Redis实现分布式锁有什么缺陷？

